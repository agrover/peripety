// prpt monitor --event-type <> --sub-system <> --wwid <> --level <>
// prpt query --event-type <> --sub-system <> --wwid <> --level <>
// prpt blkinfo /dev/sda
//
extern crate clap;
extern crate nix;
extern crate peripety;
extern crate sdjournal;

use clap::{App, SubCommand, Arg, ArgMatches};
use nix::sys::select::FdSet;
use peripety::{LogSeverity, StorageEvent, StorageSubSystem};
use std::os::unix::io::AsRawFd;
use std::process::exit;

#[derive(Debug, Clone)]
struct Filter {
    severity: Option<LogSeverity>,
    sub_systems: Option<Vec<StorageSubSystem>>,
    event_types: Option<Vec<String>>,
}

fn quit_with_msg(msg: &str) {
    println!("{}", msg);
    exit(1);
}

fn arg_match_to_filter(matches: &ArgMatches) -> Filter {
    let mut ret = Filter {
        severity: None,
        sub_systems: None,
        event_types: None,
    };
    if matches.is_present("severity") {
        match matches.value_of("severity") {
            Some(s) => {
                ret.severity = match s.parse::<LogSeverity>() {
                    Ok(s) => Some(s),
                    Err(e) => {
                        quit_with_msg(&format!("{}", e));
                        None
                    }
                }
            }
            None => quit_with_msg("Invalid severity"),
        }
    }
    if matches.is_present("event-type") {
        match matches.values_of("event-type") {
            Some(ets) => {
                let mut event_types = Vec::new();
                for et in ets {
                    event_types.push(et.to_string());
                }
                ret.event_types = Some(event_types);
            }
            None => quit_with_msg("Invalid event-type"),
        }
    }
    if matches.is_present("sub-system") {
        match matches.values_of("sub-system") {
            Some(subs) => {
                let mut sub_systems = Vec::new();
                for s in subs {
                    match s.parse::<StorageSubSystem>() {
                        Ok(s) => sub_systems.push(s),
                        Err(e) => quit_with_msg(&format!("{}", e)),
                    }
                }
                ret.sub_systems = Some(sub_systems);
            }
            None => quit_with_msg("Invalid sub-system"),
        }
    }
    return ret;
}

fn handle_event(event: &StorageEvent, filter: &Filter) {
    let mut is_match = true;

    if let Some(l) = &filter.severity {
        if l > &event.severity {
            is_match = false;
        }
    }
    if let Some(subs) = &filter.sub_systems {
        if subs.len() != 0 && ! subs.contains(&event.sub_system) {
            is_match = false;
        }
    }

    if let Some(ets) = &filter.event_types {
        if ets.len() != 0 && ! ets.contains(&event.event_type) {
            is_match = false;
        }
    }

    if is_match {
    println!(
        "{}",
        event
            .to_json_string_pretty()
            .expect("BUG: event.to_json_string_pretty()")
    );
    }
}

fn handle_monitor(matches: &ArgMatches) {
    let filter = arg_match_to_filter(&matches);
    let mut journal =
        sdjournal::Journal::new().expect("Failed to open systemd journal");
    // We never want to block, so set the timeout to 0
    journal.timeout_us = 0;
    // Jump to the end as we cannot annotate old journal entries.
    journal
        .seek_tail()
        .expect("Unable to seek to end of journal!");

    loop {
        let mut fds = FdSet::new();
        fds.insert(journal.as_raw_fd());
        if let Err(e) =
            nix::sys::select::select(None, Some(&mut fds), None, None, None)
        {
            println!(
                "collector: Failed select against journal fd: {}",
                e
            );
            continue;
        }
        if !fds.contains(journal.as_raw_fd()) {
            continue;
        }
        for entry in &mut journal {
            match entry {
                Ok(entry) => {
                    // Skip messages generated by peripetyd.
                    if entry.get("IS_PERIPETY") != Some(&"TRUE".to_string()) {
                        continue;
                    }
                    if let Some(j) = entry.get("JSON") {
                        if let Ok(event) = StorageEvent::from_json_string(j) {
                            handle_event(&event, &filter);
                        }
                    }
                }
                Err(e) => {
                    println!("Error retrieving the journal entry: {:?}", e)
                }
            }
        }
    }
}

fn main() {
    let matches = App::new("Peripety CLI")
        .version("0.1")
        .author("Gris Ge <fge@redhat.com>")
        .about("CLI utile for peripety events")
        .subcommand(
            SubCommand::with_name("monitor")
                .about("Monitor following up events")
                .arg(
                    Arg::with_name("severity")
                        .long("severity")
                        .takes_value(true)
                        .help("Only show event with equal or higher severity"),
                    //TODO: List all possible values.
                )
                .arg(
                    Arg::with_name("event-type")
                        .long("event-type")
                        .takes_value(true)
                        .multiple(true)
                        .help(
                            "Only show event with specific event type, \
                             argument could be repeated",
                        ),
                )
                .arg(
                    Arg::with_name("sub-system")
                        .long("sub-system")
                        .takes_value(true)
                        .help(
                            "Only show event with specific event type, \
                             argument could be repeated",
                        )
                        .multiple(true),
                ),
        )
        .get_matches();

    if let Some(matches) = matches.subcommand_matches("monitor") {
        handle_monitor(matches);
        exit(0);
    }
}
